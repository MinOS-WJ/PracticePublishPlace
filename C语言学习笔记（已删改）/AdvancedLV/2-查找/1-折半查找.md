## 折半查找

- **基本思路**
- 在有序表中,取中间元素作为比较对象,若给定值与中间元素的要查找的数相等,则查找成功;若给定值小于中间元素的要查找的数,则在中间元素的左半区继续查找;
- 若给定值大于中间元素的要查找的数,则在中间元素的右半区继续查找。不断重复上述查找过 程,直到查找成功,或所查找的区域无数据元素,查找失败

---

- **实现步骤**

- 在有序表中,取中间元素作为比较对象,若给定值与中间元素的要查找的数相等,则查找成功;

- 若给定值小于中间元素的要查找的数,则在中间元素的左半区继续查找;

- 若给定值大于中间元素的要查找的数,则在中间元素的右半区继续查找。

- 不断重复上述查找过 程,直到查找成功,或所查找的区域无数据元素,查找失败。
  ![](https://img-blog.csdnimg.cn/img_convert/b394e0af450fe9756414a64877b3b0f3.png)

- **代码实现**

```c
int findKey(int values[], int length, int key) {
    // 定义一个变量记录最小索引
    int min = 0;
    // 定义一个变量记录最大索引
    int max = length - 1;
    // 定义一个变量记录中间索引
    int mid = (min + max) * 0.5;

    while (min <= max) {
        // 如果mid对应的值 大于 key, 那么max要变小
        if (values[mid] > key) {
            max = mid - 1;
            // 如果mid对应的值 小于 key, 那么min要变
        }else if (values[mid] < key) {
            min = mid + 1;
        }else {
            return mid;
        }
        // 修改完min/max之后, 重新计算mid的值
        mid = (min + max) * 0.5;
    }
    return -1;
}
```

# 